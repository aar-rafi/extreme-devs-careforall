name: CI/CD - CareForAll

on:
  # Run CI on every push to any branch
  push:
    branches:
      - main
  # Require CI on PRs into the default branch
  pull_request:
    branches:
      - main

jobs:
  detect-changed-services:
    name: Detect changed services and frontends
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.changed.outputs.services }}
      frontends: ${{ steps.changed.outputs.frontends }}
      has-services: ${{ steps.changed.outputs.has-services }}
      has-frontends: ${{ steps.changed.outputs.has-frontends }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed services
        id: changed
        shell: bash
        run: |
          set -e

          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # Compare PR branch with base branch on origin
            BASE_REF="${{ github.base_ref }}"
            git fetch origin "$BASE_REF" --depth=1
            RANGE="origin/${BASE_REF}...${{ github.sha }}"
          else
            # For direct pushes, compare with previous commit on the same branch
            RANGE="HEAD~1...HEAD"
          fi

          echo "Using diff range: $RANGE"

          CHANGED_FILES=$(git diff --name-only "$RANGE" || true)
          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Extract top-level service directory names under services/
          SERVICES=$(echo "$CHANGED_FILES" | grep '^services/' | cut -d/ -f2 | sort -u || true)

          # Check if shared package changed - rebuild all services if so
          if echo "$CHANGED_FILES" | grep -q '^shared/'; then
            echo "Shared package changed - rebuilding all services"
            SERVICES=$(ls services 2>/dev/null || echo "")
          fi

          if [ -z "$SERVICES" ]; then
            echo "No specific service changes detected."
            echo "services=[]" >> "$GITHUB_OUTPUT"
            echo "has-services=false" >> "$GITHUB_OUTPUT"
          else
            echo "Services to process:"
            echo "$SERVICES"

            # Build JSON array for matrix strategy
            SERVICES_JSON=$(printf '%s\n' "$SERVICES" | awk 'NF {gsub(/"/,"\\\""); printf "%s\"%s\"", sep, $1; sep=","} END {print ""}')

            echo "services=[$SERVICES_JSON]" >> "$GITHUB_OUTPUT"
            echo "has-services=true" >> "$GITHUB_OUTPUT"
          fi

          # Detect changed frontends (admin-dashboard, client)
          FRONTENDS_ARRAY=()
          for APP in admin-dashboard client; do
            if echo "$CHANGED_FILES" | grep -q "^${APP}/"; then
              FRONTENDS_ARRAY+=("$APP")
            fi
          done

          if [ ${#FRONTENDS_ARRAY[@]} -eq 0 ]; then
            echo "No frontend changes detected."
            echo "frontends=[]" >> "$GITHUB_OUTPUT"
            echo "has-frontends=false" >> "$GITHUB_OUTPUT"
          else
            echo "Frontends to process:"
            printf '%s\n' "${FRONTENDS_ARRAY[@]}"

            # Build JSON array
            FRONTENDS_JSON=$(printf '%s\n' "${FRONTENDS_ARRAY[@]}" | awk 'NF {gsub(/"/,"\\\""); printf "%s\"%s\"", sep, $1; sep=","} END {print ""}')
            echo "frontends=[$FRONTENDS_JSON]" >> "$GITHUB_OUTPUT"
            echo "has-frontends=true" >> "$GITHUB_OUTPUT"
          fi

  build-images:
    name: Build versioned Docker images
    needs:
      - detect-changed-services
    if: needs.detect-changed-services.outputs.has-services == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        service: ${{ fromJson(needs.detect-changed-services.outputs.services) }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image with semantic version tag
        shell: bash
        run: |
          SERVICE="${{ matrix.service }}"

          # Check if package.json exists
          if [ ! -f "services/${SERVICE}/package.json" ]; then
            echo "No package.json found for ${SERVICE}, using default version"
            VERSION="1.0.0"
          else
            VERSION=$(node -p "require('./services/${SERVICE}/package.json').version" 2>/dev/null || echo "1.0.0")
          fi

          if [ -z "$VERSION" ]; then
            echo "Could not determine version for service ${SERVICE}, using default"
            VERSION="1.0.0"
          fi

          # Image name pattern: careforall-<service>:<version>
          IMAGE_NAME="careforall-${SERVICE}"
          VERSION_TAG="${IMAGE_NAME}:v${VERSION}"
          LATEST_TAG="${IMAGE_NAME}:latest"

          echo "Building Docker image ${VERSION_TAG} (and ${LATEST_TAG})"

          docker build \
            -f "services/${SERVICE}/Dockerfile" \
            -t "${VERSION_TAG}" \
            -t "${LATEST_TAG}" \
            .

          echo "Built image tags:"
          docker images "${IMAGE_NAME}"

          # Save image as artifact for deployment
          docker save "${IMAGE_NAME}:latest" -o "/tmp/${SERVICE}-image.tar"

      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.service }}-image
          path: /tmp/${{ matrix.service }}-image.tar
          retention-days: 1

  frontend-ci:
    name: Frontend checks (admin-dashboard, client)
    needs: detect-changed-services
    if: needs.detect-changed-services.outputs.has-frontends == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        app: ${{ fromJson(needs.detect-changed-services.outputs.frontends) }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: |
            client/package-lock.json
            admin-dashboard/package-lock.json

      - name: Install dependencies
        working-directory: ${{ matrix.app }}
        run: npm ci

      - name: Run lint (if defined)
        working-directory: ${{ matrix.app }}
        shell: bash
        run: |
          if npm run | grep -qE '^\s+lint'; then
            npm run lint
          else
            echo "No lint script defined for ${{ matrix.app }}, skipping lint."
          fi

      - name: Run build (if defined)
        working-directory: ${{ matrix.app }}
        shell: bash
        run: |
          if npm run | grep -qE '^\s+build'; then
            npm run build
          else
            echo "No build script defined for ${{ matrix.app }}, skipping build."
          fi
        env:
          # Prevent out-of-memory errors during build
          NODE_OPTIONS: --max_old_space_size=4096

  deploy:
    name: Deploy to OVH VM
    needs:
      - build-images
      - frontend-ci
    # Always run deploy if on main branch, even if some jobs were skipped
    if: |
      always() &&
      github.event_name == 'push' &&
      github.ref == 'refs/heads/main' &&
      (needs.build-images.result == 'success' || needs.build-images.result == 'skipped') &&
      (needs.frontend-ci.result == 'success' || needs.frontend-ci.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - name: Deploy on OVH VM via SSH
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            set -e

            # Define installation directory
            DEPLOY_DIR="/opt/careforall"
            REPO_URL="${{ secrets.REPO_URL || 'https://github.com/aar-rafi/extreme-devs-careforall.git' }}"

            # Check if directory exists
            if [ ! -d "$DEPLOY_DIR" ]; then
              echo "Repository not found. Cloning for the first time..."
              sudo mkdir -p /opt
              cd /opt
              sudo git clone "$REPO_URL" careforall
              sudo chown -R $USER:$USER "$DEPLOY_DIR"
              cd "$DEPLOY_DIR"

              echo "Setting up environment file..."
              if [ ! -f .env ]; then
                echo "WARNING: .env file not found. Please create it manually."
                echo "You can copy .env.example if it exists."
              fi
            else
              echo "Repository exists. Pulling latest changes..."
              cd "$DEPLOY_DIR"
              git pull
            fi

            echo "Current directory: $(pwd)"
            echo "Git branch: $(git branch --show-current)"

            # Check if Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "ERROR: Docker is not installed!"
              echo "Please install Docker first: https://docs.docker.com/engine/install/"
              exit 1
            fi

            # Check if Docker Compose is available
            if ! docker compose version &> /dev/null; then
              echo "ERROR: Docker Compose plugin is not installed!"
              echo "Please install Docker Compose: https://docs.docker.com/compose/install/"
              exit 1
            fi

            echo "Building and starting services..."
            docker compose up -d --build

            echo "Waiting for services to start..."
            sleep 10

            echo "Checking running containers..."
            docker compose ps

            echo "Cleaning up unused Docker resources..."
            docker system prune -f

            echo "Deployment completed successfully!"
            echo "Services are running at:"
            echo "  - Client: http://$(hostname -I | awk '{print $1}'):4000"
            echo "  - Admin: http://$(hostname -I | awk '{print $1}'):4001"
            echo "  - API Gateway: http://$(hostname -I | awk '{print $1}'):3000"

  health-check:
    name: Post-deployment health check
    needs: deploy
    if: success()
    runs-on: ubuntu-latest

    steps:
      - name: Wait for services to start
        run: sleep 30

      - name: Check API Gateway health
        run: |
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.SSH_HOST }}:3000/health || echo "000")
          if [ "$RESPONSE" != "200" ]; then
            echo "Health check failed with status code: $RESPONSE"
            exit 1
          fi
          echo "Health check passed!"
